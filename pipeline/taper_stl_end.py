
"""
taper_stl_end.py

Standalone (non-CLI) helper for taking an STL with open ends (boundary loops)
and adding a *tapered* (smoothly shrinking) extrusion to a chosen open end.

Key features:
- Detect boundary loops ("open ends") and classify them by axis-aligned planes:
    * YZ plane -> normal ~ X axis
    * XZ plane -> normal ~ Y axis
    * XY plane -> normal ~ Z axis
- Select which end to taper by label (e.g. "XZ_minY", "XZ_maxY", "YZ", "XY")
  or use "auto" to pick the largest perimeter end.
- Extrude by a configurable length (default 14 mm) and scale down smoothly
  to a configurable target scale (default 0.5).
- Uses a smooth easing profile by default (cosine), not linear.

Dependencies:
- numpy
- trimesh

Designed to be imported and called from a pipeline:
    from pipeline.taper_stl_end import taper_stl_end

    taper_stl_end(
        input_stl_path="something_tmp.stl",
        output_stl_path="something_tapered.stl",
        target_end="XZ_minY",          # or "XZ_maxY", "YZ", "XY", "auto", ...
        extrusion_length_mm=14.0,
        target_scale=0.5
    )

No CLI parsing is used. An optional self-test block is included under
__main__ with hard-coded paths, but it does not read argv.

Author: generated by ChatGPT (GPT-5.2 Pro)
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Sequence, Tuple, Optional

import math
import numpy as np
import trimesh
from collections import defaultdict


# ----------------------------
# Data structures
# ----------------------------

@dataclass(frozen=True)
class OpenEnd:
    """
    Represents one detected open-end boundary loop.
    """
    label: str
    axis: str                 # 'X', 'Y', or 'Z' (normal axis)
    side: str                 # 'min' or 'max' (relative to mesh bounds along axis)
    centroid: np.ndarray      # (3,)
    normal: np.ndarray        # (3,) best-fit plane normal (unit)
    alignment: float          # abs(dot(normal, axis_unit))
    perimeter: float          # perimeter length of the loop
    loop: List[int]           # ordered vertex indices (cycle)


# ----------------------------
# Boundary loop detection
# ----------------------------

def _boundary_edges(mesh: trimesh.Trimesh) -> np.ndarray:
    """
    Return boundary edges as (n,2) array of vertex indices.
    Boundary edges are those that belong to exactly one face.
    """
    inv = mesh.edges_unique_inverse
    counts = np.bincount(inv, minlength=mesh.edges_unique.shape[0])
    boundary_unique = np.nonzero(counts == 1)[0]
    return mesh.edges_unique[boundary_unique]


def _connected_components_from_edges(edges: np.ndarray) -> Tuple[List[set], dict]:
    """
    Build vertex adjacency from edges and return connected components (sets of vertex indices).
    """
    adj = defaultdict(list)
    for a, b in edges:
        a = int(a); b = int(b)
        adj[a].append(b)
        adj[b].append(a)

    visited = set()
    comps: List[set] = []
    for v in list(adj.keys()):
        if v in visited:
            continue
        stack = [v]
        visited.add(v)
        comp = {v}
        while stack:
            x = stack.pop()
            for nb in adj[x]:
                if nb not in visited:
                    visited.add(nb)
                    stack.append(nb)
                    comp.add(nb)
        comps.append(comp)
    return comps, adj


def _comp_degree(v: int, comp: set, adj: dict) -> int:
    return sum(1 for nb in adj[v] if nb in comp)


def _comp_is_closed_loop(comp: set, adj: dict) -> bool:
    """
    Closed loop iff every vertex in comp has degree exactly 2 within the component.
    """
    for v in comp:
        if _comp_degree(v, comp, adj) != 2:
            return False
    return True


def _order_cycle(comp: set, adj: dict) -> List[int]:
    """
    Order vertices in a closed boundary component into a cyclic list following edges.
    Assumes the component is a simple cycle (degree==2 at all vertices).
    """
    local_adj = {v: [nb for nb in adj[v] if nb in comp] for v in comp}
    start = next(iter(comp))
    cycle = [start]
    prev = None
    cur = start
    # walk until we return to start
    while True:
        nbs = local_adj[cur]
        nxt = nbs[0] if nbs[0] != prev else nbs[1]
        if nxt == start:
            break
        cycle.append(nxt)
        prev, cur = cur, nxt
        if len(cycle) > len(comp) + 5:
            raise RuntimeError("Cycle ordering failed (unexpected topology).")
    return cycle


def _loop_perimeter(pts: np.ndarray) -> float:
    """
    Perimeter of an ordered cyclic point list.
    """
    return float(np.sum(np.linalg.norm(pts - np.roll(pts, 1, axis=0), axis=1)))


def _fit_plane_normal(pts: np.ndarray) -> Tuple[np.ndarray, np.ndarray, float]:
    """
    Fit a plane to points via SVD.
    Returns: centroid, unit normal, RMS distance to plane.
    """
    centroid = pts.mean(axis=0)
    centered = pts - centroid
    _, _, vh = np.linalg.svd(centered, full_matrices=False)
    normal = vh[-1]
    normal = normal / np.linalg.norm(normal)
    dist = centered @ normal
    rms = float(np.sqrt(np.mean(dist**2)))
    return centroid, normal, rms


def detect_open_ends(
    mesh: trimesh.Trimesh,
    *,
    axis_align_threshold: float = 0.95,
    min_loop_vertices: int = 20,
    min_perimeter: float = 5.0,
    planarity_rel_tol: float = 1e-3,
) -> Dict[str, OpenEnd]:
    """
    Detect axis-aligned open-end boundary loops in a mesh.

    Parameters
    ----------
    axis_align_threshold:
        Minimum abs(dot(normal, axis_unit)) to accept as axis-aligned.
        0.95 means within ~18 degrees; 0.99 means within ~8 degrees.
    min_loop_vertices:
        Ignore tiny loops/noise.
    min_perimeter:
        Ignore loops with very small perimeter.
    planarity_rel_tol:
        Planarity tolerance relative to mesh bounding-box diagonal.
        RMS distance to best-fit plane must be <= planarity_rel_tol * diag.

    Returns
    -------
    Dict[str, OpenEnd]
        Mapping from label -> OpenEnd. Labels include:
          - "YZ_minX" / "YZ_maxX" (normal ~ X)
          - "XZ_minY" / "XZ_maxY" (normal ~ Y)
          - "XY_minZ" / "XY_maxZ" (normal ~ Z)
        Plus convenient aliases if unambiguous:
          - "YZ" if exactly one YZ_* exists
          - "XZ" if exactly one XZ_* exists
          - "XY" if exactly one XY_* exists
        And aliases for XZ:
          - "XZ_smallY" / "XZ_lowerY" -> XZ_minY
          - "XZ_largeY" / "XZ_higherY" -> XZ_maxY
    """
    # Work on a copy so we can weld vertices for connectivity without mutating caller mesh.
    m = mesh.copy()
    # Connectivity in STL often depends on welding coincident vertices:
    m.merge_vertices()

    edges = _boundary_edges(m)
    comps, adj = _connected_components_from_edges(edges)

    bounds = m.bounds
    bbox = bounds[1] - bounds[0]
    diag = float(np.linalg.norm(bbox))
    planarity_tol = max(1e-9, planarity_rel_tol * diag)

    ends: List[OpenEnd] = []
    axis_vecs = np.eye(3)
    axis_names = ['X', 'Y', 'Z']
    plane_names = {'X': 'YZ', 'Y': 'XZ', 'Z': 'XY'}

    for comp in comps:
        if len(comp) < min_loop_vertices:
            continue
        if not _comp_is_closed_loop(comp, adj):
            continue

        loop = _order_cycle(comp, adj)
        pts = m.vertices[np.array(loop)]
        per = _loop_perimeter(pts)
        if per < min_perimeter:
            continue

        centroid, normal, rms = _fit_plane_normal(pts)
        if rms > planarity_tol:
            continue

        dots = axis_vecs @ normal
        axis_idx = int(np.argmax(np.abs(dots)))
        align = float(np.abs(dots[axis_idx]))
        if align < axis_align_threshold:
            continue

        axis = axis_names[axis_idx]
        coord = float(centroid[axis_idx])
        side = 'min' if abs(coord - bounds[0, axis_idx]) < abs(coord - bounds[1, axis_idx]) else 'max'
        base = plane_names[axis]
        label = f"{base}_{'min' if side == 'min' else 'max'}{axis}"

        ends.append(OpenEnd(
            label=label,
            axis=axis,
            side=side,
            centroid=centroid,
            normal=normal,
            alignment=align,
            perimeter=per,
            loop=loop
        ))

    out: Dict[str, OpenEnd] = {e.label: e for e in ends}

    # Add convenience aliases.
    yz = [k for k in out.keys() if k.startswith("YZ_")]
    if len(yz) == 1:
        out["YZ"] = out[yz[0]]

    xy = [k for k in out.keys() if k.startswith("XY_")]
    if len(xy) == 1:
        out["XY"] = out[xy[0]]

    xz = [k for k in out.keys() if k.startswith("XZ_")]
    if len(xz) == 1:
        out["XZ"] = out[xz[0]]

    # Friendly aliases for the "two XZ ends" use-case.
    if "XZ_minY" in out:
        out["XZ_smallY"] = out["XZ_minY"]
        out["XZ_lowerY"] = out["XZ_minY"]
    if "XZ_maxY" in out:
        out["XZ_largeY"] = out["XZ_maxY"]
        out["XZ_higherY"] = out["XZ_maxY"]

    return out


# ----------------------------
# Tapered extrusion
# ----------------------------

def _smooth_profile(t: float, *, kind: str = "cosine", exponent: float = 1.0) -> float:
    """
    Map t in [0,1] to a smooth progression s in [0,1].

    kind:
      - "cosine"    : 0.5 - 0.5*cos(pi*t) (zero slope at ends)
      - "smoothstep": t^2*(3-2t) (also zero slope at ends)
      - "linear"    : s=t (NOT smooth)
      - "sigmoid"   : logistic-like with sharper middle (exponent controls sharpness)

    exponent:
      - For cosine/smoothstep/linear, raises s^exponent (exponent>1 biases shrink later).
      - For sigmoid, exponent controls logistic steepness.
    """
    t = float(np.clip(t, 0.0, 1.0))
    if kind == "linear":
        s = t
    elif kind == "smoothstep":
        s = t * t * (3.0 - 2.0 * t)
    elif kind == "cosine":
        s = 0.5 - 0.5 * math.cos(math.pi * t)
    elif kind == "sigmoid":
        # logistic-like curve; remap to exactly hit 0 and 1 at endpoints
        k = 10.0 * float(exponent)
        raw = 1.0 / (1.0 + math.exp(-k * (t - 0.5)))
        lo = 1.0 / (1.0 + math.exp(k * 0.5))
        hi = 1.0 / (1.0 + math.exp(-k * 0.5))
        s = (raw - lo) / (hi - lo)
    else:
        raise ValueError(f"Unknown profile kind: {kind!r}")

    if exponent != 1.0 and kind not in ("sigmoid",):
        s = s ** float(exponent)

    return float(np.clip(s, 0.0, 1.0))


def add_tapered_extension(
    mesh: trimesh.Trimesh,
    loop: Sequence[int],
    direction: np.ndarray,
    *,
    length_mm: float = 14.0,
    target_scale: float = 0.5,
    n_sections: int = 24,
    profile: str = "cosine",
    profile_exponent: float = 1.0,
) -> trimesh.Trimesh:
    """
    Add a tapered extrusion to a boundary loop.

    The original loop becomes the start ring (t=0, scale=1).
    The new outlet ring at the end is scaled to `target_scale`.

    Parameters
    ----------
    mesh:
        Input mesh (should already have the boundary loop).
    loop:
        Ordered list of vertex indices forming a closed cycle.
    direction:
        3-vector (will be normalized). Extrusion direction (outward).
    length_mm:
        Extrusion length.
    target_scale:
        Final scale of the loop cross-section (0 < target_scale <= 1).
        Example: 0.5 => 50% of original.
    n_sections:
        Number of interpolation segments along the length (higher => smoother).
        Creates n_sections rings between start and end (end included).
    profile:
        See _smooth_profile().
    profile_exponent:
        Controls curvature of the taper.

    Returns
    -------
    trimesh.Trimesh
        New mesh with the tapered side-wall faces appended.
        The end remains OPEN (no cap is added).
    """
    if length_mm <= 0:
        raise ValueError("length_mm must be > 0")
    if not (0.0 < target_scale <= 1.0):
        raise ValueError("target_scale must be in (0, 1]")
    if n_sections < 2:
        raise ValueError("n_sections must be >= 2")

    direction = np.asarray(direction, dtype=float)
    norm = float(np.linalg.norm(direction))
    if norm <= 0:
        raise ValueError("direction must be a non-zero vector")
    direction = direction / norm

    loop = list(map(int, loop))
    pts0 = mesh.vertices[np.array(loop)]
    center = pts0.mean(axis=0)

    # Ensure loop winding is consistent with extrusion direction.
    # If area normal points opposite the extrusion direction, reverse loop.
    area_vec = np.zeros(3, dtype=float)
    for i in range(len(loop)):
        p = pts0[i] - center
        q = pts0[(i + 1) % len(loop)] - center
        area_vec += np.cross(p, q)
    if float(np.dot(area_vec, direction)) < 0.0:
        loop.reverse()
        pts0 = pts0[::-1]

    base_vertices = mesh.vertices.copy()
    base_faces = mesh.faces.copy()
    v_count = base_vertices.shape[0]

    rings: List[np.ndarray] = [np.array(loop, dtype=int)]
    new_vertex_blocks: List[np.ndarray] = []

    # Build new rings (excluding ring0 which reuses existing vertices).
    m = len(loop)
    for j in range(1, n_sections + 1):
        t = j / n_sections
        s = _smooth_profile(t, kind=profile, exponent=profile_exponent)
        scale = 1.0 - (1.0 - float(target_scale)) * s
        offset = float(length_mm) * t

        diff = pts0 - center
        # Project to the plane perpendicular to direction before scaling.
        diff_plane = diff - np.outer(diff @ direction, direction)

        pts_scaled = center + diff_plane * scale
        pts_extruded = pts_scaled + direction * offset

        new_vertex_blocks.append(pts_extruded)
        ring_idx = np.arange(v_count, v_count + m, dtype=int)
        v_count += m
        rings.append(ring_idx)

    added_vertices = np.vstack(new_vertex_blocks) if new_vertex_blocks else np.zeros((0, 3), dtype=float)
    vertices_out = np.vstack([base_vertices, added_vertices])

    # Side-wall faces (quads split into triangles)
    faces_new: List[List[int]] = []
    for j in range(n_sections):
        r0 = rings[j]
        r1 = rings[j + 1]
        for i in range(m):
            a = int(r0[i])
            b = int(r0[(i + 1) % m])
            c = int(r1[(i + 1) % m])
            d = int(r1[i])
            faces_new.append([a, b, c])
            faces_new.append([a, c, d])

    faces_out = np.vstack([base_faces, np.asarray(faces_new, dtype=int)])
    return trimesh.Trimesh(vertices=vertices_out, faces=faces_out, process=False)


# ----------------------------
# Top-level pipeline-friendly API
# ----------------------------

def taper_stl_end(
    *,
    input_stl_path: str,
    output_stl_path: str,
    target_end: str = "auto",
    extrusion_length_mm: float = 14.0,
    target_scale: float = 0.5,
    n_sections: int = 24,
    profile: str = "cosine",
    profile_exponent: float = 1.0,
    axis_align_threshold: float = 0.95,
) -> Dict[str, OpenEnd]:
    """
    Load an STL, detect open ends, select one, add a tapered extension, and write a new STL.

    Returns the detected open ends (including aliases) from the *input* mesh,
    so your pipeline can log/inspect what was available.

    Selection
    ---------
    - If target_end == "auto": chooses the axis-aligned end with the largest perimeter.
    - Otherwise: target_end must match one of the returned keys from detect_open_ends(),
      e.g. "XZ_minY", "XZ_maxY", "YZ_minX", "XY_maxZ", or "YZ"/"XY" aliases.

    Notes
    -----
    - Extrusion direction is inferred from the end side:
        * "min" side -> along negative axis
        * "max" side -> along positive axis
    - The end is not capped: the outlet remains open.
    """
    mesh = trimesh.load_mesh(input_stl_path, process=False)

    ends = detect_open_ends(mesh, axis_align_threshold=axis_align_threshold)
    if not ends:
        raise RuntimeError(
            "No axis-aligned closed boundary loops were detected. "
            "Try lowering axis_align_threshold or min_loop_vertices, or verify the STL has open ends."
        )

    # Select end
    if target_end == "auto":
        # choose by largest perimeter among non-alias labels (the ones containing '_')
        candidates = [e for k, e in ends.items() if "_" in k]
        if not candidates:
            # fall back to any key
            candidates = list(ends.values())
        selected = max(candidates, key=lambda e: e.perimeter)
    else:
        if target_end not in ends:
            # If the caller asked for a plane name ("XY"/"XZ"/"YZ") but multiple ends exist,
            # select the largest-perimeter one for that plane instead of erroring.
            if target_end in ("XY", "XZ", "YZ"):
                prefix = target_end + "_"
                candidates = [e for k, e in ends.items() if k.startswith(prefix)]
                if candidates:
                    selected = max(candidates, key=lambda e: e.perimeter)
                else:
                    available = sorted(set(ends.keys()))
                    raise KeyError(
                        f"target_end={target_end!r} not found and no keys start with {prefix!r}. "
                        f"Available keys: {available}"
                    )
            else:
                available = sorted(set(ends.keys()))
                raise KeyError(
                    f"target_end={target_end!r} not found. Available keys: {available}"
                )
        else:
            selected = ends[target_end]

    # Direction from axis+side
    axis_to_idx = {"X": 0, "Y": 1, "Z": 2}
    axis_idx = axis_to_idx[selected.axis]
    direction = np.zeros(3, dtype=float)
    direction[axis_idx] = -1.0 if selected.side == "min" else 1.0

    # Weld vertices once before extrusion so boundary connectivity uses shared indices.
    mesh.merge_vertices()

    mesh_out = add_tapered_extension(
        mesh,
        selected.loop,
        direction,
        length_mm=extrusion_length_mm,
        target_scale=target_scale,
        n_sections=n_sections,
        profile=profile,
        profile_exponent=profile_exponent,
    )

    mesh_out.export(output_stl_path)
    return ends


def inspect_open_ends(input_stl_path: str, *, axis_align_threshold: float = 0.95) -> Dict[str, OpenEnd]:
    """
    Convenience wrapper for pipelines to list detected open ends without writing output.
    """
    mesh = trimesh.load_mesh(input_stl_path, process=False)
    return detect_open_ends(mesh, axis_align_threshold=axis_align_threshold)


# ----------------------------
# Optional self-test (no CLI args)
# ----------------------------

if __name__ == "__main__":
    # Hard-coded example (edit paths if you want to run as a script).
    # This is intentionally NOT a CLI.
    example_in = "sim_126e5ab3_tmp.stl"
    example_out = "sim_126e5ab3_tmp_tapered.stl"

    try:
        ends = taper_stl_end(
            input_stl_path=example_in,
            output_stl_path=example_out,
            target_end="auto",
            extrusion_length_mm=14.0,
            target_scale=0.5,
            n_sections=24,
            profile="cosine",
        )
        # Print a small summary
        keys = sorted(set(k for k in ends.keys() if "_" in k))
        print("Detected ends:", keys)
        print("Wrote:", example_out)
    except Exception as e:
        print("Self-test failed:", e)
